package com.example.damien.projetir.CustomEdit;

import android.content.Context;
import android.graphics.Color;
import android.text.Editable;
import android.text.SpannableString;
import android.text.TextWatcher;
import android.text.style.ForegroundColorSpan;
import android.util.AttributeSet;
import android.util.Log;
import android.view.DragEvent;
import android.view.MotionEvent;
import android.view.inputmethod.InputMethodManager;
import android.widget.EditText;
import android.widget.Toast;

import com.example.damien.projetir.Tests.Difficulty.Difficulty;
import com.example.damien.projetir.Tests.Distance.Distance;
import com.example.damien.projetir.Tests.Orientation.Orientation;

/**
 * Created by Damien on 01/12/2015.
 * No Warning
 */


public class CustomEdit extends EditText
{

     private boolean fingerState;
    private int editPosition;
    private int previousPosition;
    private boolean autoGeneratedSelecton;



    public enum LogAction {LOG_ACTION_TYPE,LOG_ACTION_DELETE, LOG_ACTION_MOVE, LOG_ACTION_AUTOMOVE, LOG_ACTION_START, LOG_ACTION_STOP, LOG_ACTION_RETURN, LOG_ACTION_INIT, LOG_ACTION_NEWTEST}
    private LogAction previousLogAction;
    private boolean started;
    private float chronometer;
    private String dataLogs;                                                                        //Variable contenant les logs, complété à chaque action,



    public KeyLogData getKeyLogD()
    {
        return keyLogD;
    }

    public void setKeyLogD(KeyLogData keyLogD)
    {
        this.keyLogD = keyLogD;
    }

    private KeyLogData keyLogD;

    private Difficulty _difficulty;
    private int _textSize;
    private Orientation _orientation;
    private Distance _distance;
    private int _nbErrors;
    public boolean _selectionChangeable;





    public void setPreviousLogAction(LogAction action)
    {
        previousLogAction = action;
    }

    public LogAction getPreviousLogAction()
    {
        return this.previousLogAction;
    }

    public String getDataLogs()
    {
        return dataLogs;
    }

    public void setDataLogs(String dataLogs)
    {
        this.dataLogs = dataLogs;
    }
    public void writeSingleDataLogs(String data)
    {

        setDataLogs(getDataLogs() + data);
    }

    public void writeDataLogs(LogAction currentAction,String msg)
    {
        if(getPreviousLogAction() == null)
        {
            writeSingleDataLogs("Error : No Previous Action");
        }
        else if(!getPreviousLogAction().name().matches(currentAction.name()))
        {
            writeSingleDataLogs("</>");
            writeSingleDataLogs("\n");
            writeSingleDataLogs("<" + currentAction.name() + ">");
            writeSingleDataLogs("\n");
        }

        if(!currentAction.name().matches(LogAction.LOG_ACTION_STOP.name()))
        {
            writeSingleDataLogs(Float.toString(getCurrentTime() / 1000000000) + " : " + msg);
            writeSingleDataLogs("\n");
        }
        else
        {
            writeSingleDataLogs("</>");
            writeSingleDataLogs("\n");
        }
        setPreviousLogAction(currentAction);
    }
    public void resetDataLogs()
    {
        this.dataLogs = "";
    }


    public int get_nbErrors()
    {
        return _nbErrors;
    }

    public void set_nbErrors(int _nbErrors)
    {
        this._nbErrors = _nbErrors;
    }
    public void addError()
    {
        this._nbErrors++;
    }

    public Distance get_Distance()
    {
        return _distance;
    }

    public void set_Distance(Distance _distance)
    {
        this._distance = _distance;
    }

    public int get_TextSize()
    {
        return _textSize;
    }

    public void set_TextSize(int textSize)
    {
        this._textSize = textSize;
    }

    public Difficulty get_Difficulty()
    {
        return _difficulty;
    }

    public void set_Difficulty(Difficulty difficulty)
    {
        this._difficulty = difficulty;
    }

    public Orientation get_Orientation()
    {
        return _orientation;
    }

    public void set_Orientation(Orientation orientation)
    {
        this._orientation = orientation;
    }

    public boolean isTestCompleted()
    {
        //Test de validité du test, ici on test si l'état du delete est 1
        //-1 = InitState, 1 le delete a été fait; 0 le delete etait faux
        return keyLogD.getDeleteDone() == 1;// && getTextSize() == get_TextSize()-1;
    }

    public boolean isStarted() {
        return started;
    }

    public void setStarted(boolean started)
    {
        if(started)
        {
            writeSingleDataLogs("<" + LogAction.LOG_ACTION_START.name() + ">");
            writeSingleDataLogs("\n");
            writeSingleDataLogs("New test prepared with following text : " + "\n" + this.getText());
            writeSingleDataLogs("\n");
            setPreviousLogAction(LogAction.LOG_ACTION_START);
        }
        else
        {
            writeDataLogs(LogAction.LOG_ACTION_STOP,"");
            Log.w("FINAL DATA LOG : ", getDataLogs());
        }

        this.started = started;

    }

    public float getChronometer() {
        return chronometer;
    }

    public void setChronometer(float chronometer) {
        this.chronometer = chronometer;
    }

    public float getCurrentTime()
    {
        return System.nanoTime() - getChronometer();
    }

    public void startChrono()
    {
        this.setChronometer(System.nanoTime());
    }

    public void stopChrono()
    {
        float chronoValue = System.nanoTime() - getChronometer(); // nanoTime pour être précis, sinon l'update n'est pas assez rapide et on a des temps de 0.0
        this.setChronometer(chronoValue);

    }


    private TextWatcher textController = new TextWatcher()
    {
        @Override
        public void beforeTextChanged(CharSequence s, int start, int count, int after)
        {

        }

        @Override
        public void onTextChanged(CharSequence s, int start, int before, int count)
        {
            autoGeneratedSelecton = true;                                                           //Marche une fois sur deux
            if(count < get_TextSize()) {//Si l'event n'est pas généré via generateText()


                if(isStarted()) {
                    if (keyLogD.getDeleteDone() == 0)//Ici on a delete un mauvais caractère
                    {
                        writeDataLogs(LogAction.LOG_ACTION_DELETE,"ERROR : Start : " + Integer.toString(start));
                        reloadDueToError();
                    }
                    if (keyLogD.getDeleteDone() == 1)//Si on a supprimer le bon caractère, on le log
                        writeDataLogs(LogAction.LOG_ACTION_DELETE,"SUCCESS : Start : " + Integer.toString(start));

                    if (!(s.subSequence(start, start + count).length() == 0 || s.toString().length() == 0)) //Ajout d'un caractère
                    {
                        writeDataLogs(LogAction.LOG_ACTION_TYPE,"ERROR : " + Integer.toString(start));
                        reloadDueToError();
                    }
                }
                else
                {
                    if (s.charAt(start) == ' ') {
                        setStarted(true);
                        reloadTest();
                        startChrono();
                    }
                    else
                        reloadTest();
                }
            }


        }

        @Override
        public void afterTextChanged(Editable s)
        {
        }
    };

    public CustomEdit(Context context) {
        super(context);
        initialisation();
    }

    public CustomEdit(Context context, AttributeSet attrs) {
        super(context, attrs);
        initialisation();
    }

    public void initialisation()
    {

        resetDataLogs();
        setPreviousLogAction(LogAction.LOG_ACTION_INIT);

        addTextChangedListener(textController);
        keyLogD = new KeyLogData(false,-1,false,false,false);
        setFingerState(true);
        set_nbErrors(0);
        this.started = false;

    }


    public void setFingerState(boolean b)
    {
        fingerState = b;
        keyLogD.setPadsDisabled(b);
        _selectionChangeable = !b;//Variable utilisée pour un eventuel cancel du Keyboardshift
    }

    public boolean getFingerState()
    {
        return fingerState;
    }

    public void showKeyboard()//Affiche le clavier sans avoir besoin de tapper le text edit
    {
        requestFocus();
        InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        imm.showSoftInput(this, InputMethodManager.SHOW_IMPLICIT);
    }

    public void hideKeyboard()
    {
        InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        imm.hideSoftInputFromWindow(this.getWindowToken(), 0);
    }

    public void generateText()
    {
        autoGeneratedSelecton = true;

        SpannableString string;
        string = new SpannableString("Lorem ipsum dol" + get_Difficulty().getLetters() +"sit amet, elit.");
        set_TextSize(string.length());


        editPosition = string.length()/2;

        string.setSpan(new ForegroundColorSpan(Color.RED), editPosition - 1, editPosition + 2, 0);

        this.setText(string);

        //Cette fonction deviendrait :
        //this.setText(TestType.generateText());

    }
                                                                                                    //Pour les tracktests : faire un objet TestType;
                                                                                                    //TestType = new ShiftTest(); par exemple
                                                                                                    //avec fonction generateText, et setPosition, qui feront les bons textes et bons placement de position
    public void setCursor()
    {
        int position;

        if(get_Orientation().getOrientation().equalsIgnoreCase("Left"))
        {
            position = (editPosition - get_Distance().getCursorPosition());
        }
        else
        {
            position = (editPosition + get_Distance().getCursorPosition());
        }

        autoGeneratedSelecton = true;
        writeDataLogs(LogAction.LOG_ACTION_AUTOMOVE, "SELECTION MOVED : Position : " + Integer.toString(position));
        setSelection(position);
    }

    public void resetForNewTest()
    {
        reloadTest();
        set_nbErrors(0);
    }

    public void reloadDueToError()
    {
        addError();
        reloadTest();
    }

    public void reloadTest()
    {
        if(get_Distance() == null || get_Difficulty() == null)
            Toast.makeText(getContext(), "No context left", Toast.LENGTH_SHORT).show();
        else
        {
            keyLogD.setEnabled(false);
            keyLogD.setDeleteDone(-1);
            keyLogD.setReturnPressed(false);
            generateText();
            setCursor();
        }
    }

    @Override
    public boolean onTouchEvent(MotionEvent event)
    {

        if (!isStarted())
            return false;

        //Si on est pas en mode finger, on renvoie faux, sinon on laisse OnTouchEvent mère gérer.
        return fingerState && super.onTouchEvent(event);

    }



    @Override
    protected void onSelectionChanged(int selStart, int selEnd)
    {
        super.onSelectionChanged(selStart, selEnd);


        if(!autoGeneratedSelecton)
        {
            if (!(keyLogD == null))
            {
                if (isStarted())
                    writeDataLogs(LogAction.LOG_ACTION_MOVE, "SELECTION MOVE : Start : " + Integer.toString(selStart) + " - SelEnd : " + Integer.toString(selEnd));

                if (selStart == this.editPosition + 1) //Si on a bougé au bon endroit, on enable le droit de supprimer, sinon on disable
                    keyLogD.setEnabled(true);
                else
                    keyLogD.setEnabled(false);
            }
        }
        autoGeneratedSelecton = false;
    }
}
